/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package tictactoe;

import java.io.*;

/**
 *
 * @author Eyal Blumental Erez
 */
public class UserInput extends javax.swing.JFrame {

    /**
     * Creates new form UserInput
     */
    public UserInput() {
        initComponents();
    }

    //Determines which player plays, when X is placed down this string is changed from X to O and vise versa.
    public String turnChoice = "X";

    //Determines when a draw is in place once this value reaches 9 and there is no winner then the code knows it's a draw
    public int numButtonsClicked = 0;

    public boolean playerWon = false;

//Creates a 2d array that allows the AI to be able to see what the player has inputted when vsing the AI
    public static String playerViewGame[][] = new String[3][3];

    //Determines the game type so that the code knows which gamemode to be playing
    public String gameType = "";

    //Helps the AI figure out if there is an empty space available to put it's 0 when using the randomizer (Math.random())
    public boolean foundEmptySpace = false;

    //Creates xAxis to help the AI determine the best available spot to place down their O by putting it in the []
    public int xAxis = 0;

    //Creates yAxis to help AI determine the best available spot to place down their O by putting it in the [] similar to xAxis
    public int yAxis = 0;

    //Allows the embeded java code for Math.random() to be used to allow AI to determine the best possible spot to place down O for the x axis
    public double x = 0;

    //Allows the embeded java code for Math.random() to be used to allow the AI to determine the best possible spot to place down O for the y axis
    public double y = 0;

    //This int variable allows the AI to know where there is a used space in the tic tac toe game which means that the AI cannot place it's O there
    int foundUsedSpace = 0;

    //This int variable allows the AI to know where there is an empty space and is used in a few if statements that check if it is the most optimal move to make for the AI
    int emptySpace = 0;

    //This boolean is used to make sure that if the player has not made any moves that the AI recognises as a potential win, then it will use a randomiser that is based around this boolean
    public boolean needToPick = true;

    //This boolean is used in the AI's code where it allows it to figure out if there is an available spot for the AI to place down it's O and the exact position that it's in.
    public boolean foundASpot = false;

    //This boolean makes sure that it is the AI's turn this boolean is turned true when the AIChoose method is called and disabled when it's turn is over at the end of the AIChoose method.
    boolean AITurn = false;

    boolean foundSpareSpace = false;

    //PositionValue simply tells the AI where the position of it's decided move
    int positionValue = 0;

    //Counts the number of wins of X, this varible goes up every time X wins in the checkWin method
    int xNumWins = 0;

    //Counts the number of wins of O, this varible goes up every time O wins in the checkWin method
    int oNumWins = 0;

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        topRightButton = new javax.swing.JButton();
        topMidButton = new javax.swing.JButton();
        topLeftButton = new javax.swing.JButton();
        midLeftButton = new javax.swing.JButton();
        midMidButton = new javax.swing.JButton();
        midRightButton = new javax.swing.JButton();
        bottomRightButton = new javax.swing.JButton();
        bottomMidButton = new javax.swing.JButton();
        bottomLeftButton = new javax.swing.JButton();
        messageText = new javax.swing.JLabel();
        title = new javax.swing.JLabel();
        twoPlayerButton = new javax.swing.JButton();
        playerAIButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        firstPlace = new javax.swing.JTextField();
        secondPlace = new javax.swing.JTextField();
        thirdPlace = new javax.swing.JTextField();
        fourthPlace = new javax.swing.JTextField();
        fifthPlace = new javax.swing.JTextField();
        sixthPlace = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        nameText = new javax.swing.JTextField();
        highscoreText = new javax.swing.JLabel();
        submitName = new javax.swing.JButton();
        xWins = new javax.swing.JLabel();
        oWins = new javax.swing.JLabel();
        firstPlaceCount = new javax.swing.JTextField();
        secondPlaceCount = new javax.swing.JTextField();
        thirdPlaceCount = new javax.swing.JTextField();
        fourthPlaceCount = new javax.swing.JTextField();
        fifthPlaceCount = new javax.swing.JTextField();
        sixthPlaceCount = new javax.swing.JTextField();
        playAgainButton = new javax.swing.JButton();

        jButton1.setText("jButton1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        topRightButton.setFont(new java.awt.Font("Times New Roman", 1, 70)); // NOI18N
        topRightButton.setEnabled(false);
        topRightButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                topRightButtonActionPerformed(evt);
            }
        });

        topMidButton.setFont(new java.awt.Font("Times New Roman", 1, 70)); // NOI18N
        topMidButton.setEnabled(false);
        topMidButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                topMidButtonActionPerformed(evt);
            }
        });

        topLeftButton.setFont(new java.awt.Font("Times New Roman", 1, 70)); // NOI18N
        topLeftButton.setEnabled(false);
        topLeftButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                topLeftButtonActionPerformed(evt);
            }
        });

        midLeftButton.setFont(new java.awt.Font("Times New Roman", 1, 70)); // NOI18N
        midLeftButton.setEnabled(false);
        midLeftButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                midLeftButtonActionPerformed(evt);
            }
        });

        midMidButton.setFont(new java.awt.Font("Times New Roman", 1, 70)); // NOI18N
        midMidButton.setEnabled(false);
        midMidButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                midMidButtonActionPerformed(evt);
            }
        });

        midRightButton.setFont(new java.awt.Font("Times New Roman", 1, 70)); // NOI18N
        midRightButton.setEnabled(false);
        midRightButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                midRightButtonActionPerformed(evt);
            }
        });

        bottomRightButton.setFont(new java.awt.Font("Times New Roman", 1, 70)); // NOI18N
        bottomRightButton.setEnabled(false);
        bottomRightButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bottomRightButtonActionPerformed(evt);
            }
        });

        bottomMidButton.setFont(new java.awt.Font("Times New Roman", 1, 70)); // NOI18N
        bottomMidButton.setEnabled(false);
        bottomMidButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bottomMidButtonActionPerformed(evt);
            }
        });

        bottomLeftButton.setFont(new java.awt.Font("Times New Roman", 1, 70)); // NOI18N
        bottomLeftButton.setEnabled(false);
        bottomLeftButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bottomLeftButtonActionPerformed(evt);
            }
        });

        messageText.setFont(new java.awt.Font("Times New Roman", 0, 24)); // NOI18N

        title.setFont(new java.awt.Font("Times New Roman", 1, 24)); // NOI18N
        title.setText("Tictactoe");

        twoPlayerButton.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        twoPlayerButton.setText("Two Player");
        twoPlayerButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                twoPlayerButtonActionPerformed(evt);
            }
        });

        playerAIButton.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        playerAIButton.setText("Player Vs AI");
        playerAIButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                playerAIButtonActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Times New Roman", 1, 24)); // NOI18N
        jLabel1.setText("Leaderboard");

        firstPlace.setEditable(false);

        secondPlace.setEditable(false);

        thirdPlace.setEditable(false);
        thirdPlace.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                thirdPlaceActionPerformed(evt);
            }
        });

        fourthPlace.setEditable(false);
        fourthPlace.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fourthPlaceActionPerformed(evt);
            }
        });

        fifthPlace.setEditable(false);
        fifthPlace.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fifthPlaceActionPerformed(evt);
            }
        });

        sixthPlace.setEditable(false);
        sixthPlace.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sixthPlaceActionPerformed(evt);
            }
        });

        jLabel2.setText("1st Place:");

        jLabel3.setText("2nd Place:");

        jLabel4.setText("3rd Place:");

        jLabel5.setText("4th Place:");

        jLabel6.setText("5th Place:");

        jLabel7.setText("6th Place:");

        nameText.setEnabled(false);
        nameText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nameTextActionPerformed(evt);
            }
        });

        highscoreText.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        highscoreText.setText("Highscore Name:");

        submitName.setText("Submit Name");
        submitName.setEnabled(false);
        submitName.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                submitNameActionPerformed(evt);
            }
        });

        xWins.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        xWins.setText("X Wins = 0");

        oWins.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        oWins.setText("O Wins = 0");

        firstPlaceCount.setEditable(false);
        firstPlaceCount.setText("0");

        secondPlaceCount.setEditable(false);
        secondPlaceCount.setText("0");

        thirdPlaceCount.setEditable(false);
        thirdPlaceCount.setText("0");

        fourthPlaceCount.setEditable(false);
        fourthPlaceCount.setText("0");

        fifthPlaceCount.setEditable(false);
        fifthPlaceCount.setText("0");

        sixthPlaceCount.setEditable(false);
        sixthPlaceCount.setText("0");

        playAgainButton.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        playAgainButton.setText("Play Again");
        playAgainButton.setActionCommand("");
        playAgainButton.setEnabled(false);
        playAgainButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                playAgainButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(bottomLeftButton, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(midLeftButton, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(topLeftButton, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(topMidButton, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGap(18, 18, 18)
                            .addComponent(topRightButton, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(midMidButton, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGap(18, 18, 18)
                            .addComponent(midRightButton, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(bottomMidButton, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(bottomRightButton, javax.swing.GroupLayout.PREFERRED_SIZE, 227, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(131, 131, 131)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(firstPlace, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jLabel1)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(secondPlace, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel4)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(thirdPlace, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel5)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(fourthPlace, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel6)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(fifthPlace, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel7)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(sixthPlace, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(firstPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(secondPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(thirdPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(fourthPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(fifthPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(sixthPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(203, 203, 203)
                                        .addComponent(title))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(36, 36, 36)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(oWins)
                                            .addComponent(xWins))))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(twoPlayerButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(playerAIButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(messageText, javax.swing.GroupLayout.DEFAULT_SIZE, 487, Short.MAX_VALUE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(23, 23, 23)
                                        .addComponent(highscoreText)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(submitName)
                                            .addComponent(nameText, javax.swing.GroupLayout.PREFERRED_SIZE, 136, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGap(0, 0, Short.MAX_VALUE))
                                    .addComponent(playAgainButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                        .addContainerGap())))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(topLeftButton, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(topMidButton, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(topRightButton, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(midRightButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(midLeftButton, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(midMidButton, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE))))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(title)
                        .addGap(18, 18, 18)
                        .addComponent(twoPlayerButton, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(playerAIButton, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(playAgainButton, javax.swing.GroupLayout.PREFERRED_SIZE, 43, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel1)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(firstPlace, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2)
                            .addComponent(firstPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(secondPlace, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3)
                            .addComponent(secondPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(thirdPlace, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4)
                            .addComponent(thirdPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(fourthPlace, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel5)
                            .addComponent(fourthPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(fifthPlace, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel6)
                            .addComponent(fifthPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(sixthPlace, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel7)
                            .addComponent(sixthPlaceCount, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(9, 9, 9)
                        .addComponent(xWins)
                        .addGap(5, 5, 5)
                        .addComponent(oWins)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(messageText, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(highscoreText)
                            .addComponent(nameText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(16, 16, 16)
                        .addComponent(submitName)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addGap(26, 26, 26)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(bottomMidButton, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(bottomRightButton, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(bottomLeftButton, javax.swing.GroupLayout.PREFERRED_SIZE, 196, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(43, Short.MAX_VALUE))))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * This method checks if turn choice is X or O which is either player one's
     * turn or player two's turn, uses a string and changes value to "O" once
     * it's finished checking is player has won by getting the text of the
     * buttons and seeing what they equal in an if statement. If the game type
     * is for an AI then a new variable will be introduced which is the 2d array
     * that allows the AI to determine the best possible position to place it's
     * O down when versing the player. It then checks for a win or a draw and
     * then calls a method that allows the AI to make it's choice once the
     * player has placed down their X.
     */
    private void topRightButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_topRightButtonActionPerformed

        if (gameType == "twoPlayer") {

            if (turnChoice == "X") {

                topRightButton.setText("X");

                turnChoice = "O";

            } else if (turnChoice == "O") {

                topRightButton.setText("O");

                turnChoice = "X";

            }

            numButtonsClicked++;

            topRightButton.setEnabled(false);

            checkWin();

            checkDraw();

        } else if (gameType == "PlayerVsAI") {

            topRightButton.setText("X");

            topRightButton.setEnabled(false);

            playerViewGame[0][2] = "X";

            numButtonsClicked++;

            checkWin();

            checkDraw();

            if (playerWon == false) {

                //If playerVsAI game type is chosen then as long as there is no winner then the AIChoose method is called after a player makes a choice so that the AI can make it's move
                AIChoose();

            }

        }

    }//GEN-LAST:event_topRightButtonActionPerformed
    /**
     * This method checks if turn choice is X or O which is either player one's
     * turn or player two's turn, uses a string and changes value to "O" once
     * it's finished checking is player has won by getting the text of the
     * buttons and seeing what they equal in an if statement. If the game type
     * is for an AI then a new variable will be introduced which is the 2d array
     * that allows the AI to determine the best possible position to place it's
     * O down when versing the player. It then checks for a win or a draw and
     * then calls a method that allows the AI to make it's choice once the
     * player has placed down their X.
     */
    private void topMidButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_topMidButtonActionPerformed

        //Checks which game type the player has chosen
        if (gameType == "twoPlayer") {

            //Checks which turn the next move is for then changes X to O for the next turn and vise versa
            if (turnChoice == "X") {

                topMidButton.setText("X");

                turnChoice = "O";

            } else if (turnChoice == "O") {

                topMidButton.setText("O");

                turnChoice = "X";

            }

            numButtonsClicked++;

            topMidButton.setEnabled(false);

            checkWin();

            checkDraw();

        } else if (gameType == "PlayerVsAI") {

            topMidButton.setText("X");

            topMidButton.setEnabled(false);

            playerViewGame[0][1] = "X";

            numButtonsClicked++;

            checkWin();

            checkDraw();

            if (playerWon == false) {

                AIChoose();

            }

        }


    }//GEN-LAST:event_topMidButtonActionPerformed
    /**
     * This method checks if turn choice is X or O which is either player one's
     * turn or player two's turn, uses a string and changes value to "O" once
     * it's finished checking is player has won by getting the text of the
     * buttons and seeing what they equal in an if statement. If the game type
     * is for an AI then a new variable will be introduced which is the 2d array
     * that allows the AI to determine the best possible position to place it's
     * O down when versing the player. It then checks for a win or a draw and
     * then calls a method that allows the AI to make it's choice once the
     * player has placed down their X.
     */
    private void topLeftButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_topLeftButtonActionPerformed

        if (gameType == "twoPlayer") {

            if (turnChoice == "X") {

                topLeftButton.setText("X");

                turnChoice = "O";

            } else if (turnChoice == "O") {

                topLeftButton.setText("O");

                turnChoice = "X";

            }

            numButtonsClicked++;

            topLeftButton.setEnabled(false);

            checkWin();

            checkDraw();

        } else if (gameType == "PlayerVsAI") {

            topLeftButton.setText("X");

            topLeftButton.setEnabled(false);

            playerViewGame[0][0] = "X";

            numButtonsClicked++;

            checkWin();

            checkDraw();

            if (playerWon == false) {

                AIChoose();

            }

        }

    }//GEN-LAST:event_topLeftButtonActionPerformed
    /**
     * This method checks if turn choice is X or O which is either player one's
     * turn or player two's turn, uses a string and changes value to "O" once
     * it's finished checking is player has won by getting the text of the
     * buttons and seeing what they equal in an if statement. If the game type
     * is for an AI then a new variable will be introduced which is the 2d array
     * that allows the AI to determine the best possible position to place it's
     * O down when versing the player. It then checks for a win or a draw and
     * then calls a method that allows the AI to make it's choice once the
     * player has placed down their X.
     */
    private void midLeftButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_midLeftButtonActionPerformed

        if (gameType == "twoPlayer") {

            if (turnChoice == "X") {

                midLeftButton.setText("X");

                turnChoice = "O";

            } else if (turnChoice == "O") {

                midLeftButton.setText("O");

                turnChoice = "X";

            }

            numButtonsClicked++;

            midLeftButton.setEnabled(false);

            checkWin();

            checkDraw();

        } else if (gameType == "PlayerVsAI") {

            midLeftButton.setText("X");

            midLeftButton.setEnabled(false);

            playerViewGame[1][0] = "X";

            numButtonsClicked++;

            checkWin();

            checkDraw();

            if (playerWon == false) {

                AIChoose();

            }

        }

    }//GEN-LAST:event_midLeftButtonActionPerformed
    /**
     * This method checks if turn choice is X or O which is either player one's
     * turn or player two's turn, uses a string and changes value to "O" once
     * it's finished checking is player has won by getting the text of the
     * buttons and seeing what they equal in an if statement. If the game type
     * is for an AI then a new variable will be introduced which is the 2d array
     * that allows the AI to determine the best possible position to place it's
     * O down when versing the player. It then checks for a win or a draw and
     * then calls a method that allows the AI to make it's choice once the
     * player has placed down their X.
     */
    private void midMidButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_midMidButtonActionPerformed

        if (gameType == "twoPlayer") {

            if (turnChoice == "X") {

                midMidButton.setText("X");

                turnChoice = "O";

            } else if (turnChoice == "O") {

                midMidButton.setText("O");

                turnChoice = "X";

            }

            numButtonsClicked++;

            midMidButton.setEnabled(false);

            checkWin();

            checkDraw();

        } else if (gameType == "PlayerVsAI") {

            midMidButton.setText("X");

            midMidButton.setEnabled(false);

            playerViewGame[1][1] = "X";

            numButtonsClicked++;

            checkWin();

            checkDraw();

            if (playerWon == false) {

                AIChoose();

            }

        }

    }//GEN-LAST:event_midMidButtonActionPerformed
    /**
     * This method checks if turn choice is X or O which is either player one's
     * turn or player two's turn, uses a string and changes value to "O" once
     * it's finished checking is player has won by getting the text of the
     * buttons and seeing what they equal in an if statement. If the game type
     * is for an AI then a new variable will be introduced which is the 2d array
     * that allows the AI to determine the best possible position to place it's
     * O down when versing the player. It then checks for a win or a draw and
     * then calls a method that allows the AI to make it's choice once the
     * player has placed down their X.
     */
    private void midRightButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_midRightButtonActionPerformed

        if (gameType == "twoPlayer") {

            if (turnChoice == "X") {

                midRightButton.setText("X");

                turnChoice = "O";

            } else if (turnChoice == "O") {

                midRightButton.setText("O");

                turnChoice = "X";

            }

            numButtonsClicked++;

            midRightButton.setEnabled(false);

            checkWin();

            checkDraw();

        } else if (gameType == "PlayerVsAI") {

            midRightButton.setText("X");

            midRightButton.setEnabled(false);

            playerViewGame[1][2] = "X";

            numButtonsClicked++;

            checkWin();

            checkDraw();

            if (playerWon == false) {

                AIChoose();

            }

        }

    }//GEN-LAST:event_midRightButtonActionPerformed
    /**
     * This method checks if turn choice is X or O which is either player one's
     * turn or player two's turn, uses a string and changes value to "O" once
     * it's finished checking is player has won by getting the text of the
     * buttons and seeing what they equal in an if statement. If the game type
     * is for an AI then a new variable will be introduced which is the 2d array
     * that allows the AI to determine the best possible position to place it's
     * O down when versing the player. It then checks for a win or a draw and
     * then calls a method that allows the AI to make it's choice once the
     * player has placed down their X.
     */
    private void bottomRightButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bottomRightButtonActionPerformed

        if (gameType == "twoPlayer") {

            if (turnChoice == "X") {

                bottomRightButton.setText("X");

                turnChoice = "O";

            } else if (turnChoice == "O") {

                bottomRightButton.setText("O");

                turnChoice = "X";

            }

            numButtonsClicked++;

            bottomRightButton.setEnabled(false);

            checkWin();

            checkDraw();

        } else if (gameType == "PlayerVsAI") {

            bottomRightButton.setText("X");

            bottomRightButton.setEnabled(false);

            playerViewGame[2][2] = "X";

            numButtonsClicked++;

            checkWin();

            checkDraw();

            if (playerWon == false) {

                AIChoose();

            }

        }

    }//GEN-LAST:event_bottomRightButtonActionPerformed
    /**
     * This method checks if turn choice is X or O which is either player one's
     * turn or player two's turn, uses a string and changes value to "O" once
     * it's finished checking is player has won by getting the text of the
     * buttons and seeing what they equal in an if statement. If the game type
     * is for an AI then a new variable will be introduced which is the 2d array
     * that allows the AI to determine the best possible position to place it's
     * O down when versing the player. It then checks for a win or a draw and
     * then calls a method that allows the AI to make it's choice once the
     * player has placed down their X.
     */
    private void bottomMidButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bottomMidButtonActionPerformed

        if (gameType == "twoPlayer") {

            if (turnChoice == "X") {

                bottomMidButton.setText("X");

                turnChoice = "O";

            } else if (turnChoice == "O") {

                bottomMidButton.setText("O");

                turnChoice = "X";

            }

            numButtonsClicked++;

            bottomMidButton.setEnabled(false);

            checkWin();

            checkDraw();

        } else if (gameType == "PlayerVsAI") {

            bottomMidButton.setText("X");

            bottomMidButton.setEnabled(false);

            playerViewGame[2][1] = "X";

            numButtonsClicked++;

            checkWin();

            checkDraw();

            if (playerWon == false) {

                AIChoose();

            }

        }

    }//GEN-LAST:event_bottomMidButtonActionPerformed
    /**
     * This method checks if turn choice is X or O which is either player one's
     * turn or player two's turn, uses a string and changes value to "O" once
     * it's finished checking is player has won by getting the text of the
     * buttons and seeing what they equal in an if statement. If the game type
     * is for an AI then a new variable will be introduced which is the 2d array
     * that allows the AI to determine the best possible position to place it's
     * O down when versing the player. It then checks for a win or a draw and
     * then calls a method that allows the AI to make it's choice once the
     * player has placed down their X.
     */
    private void bottomLeftButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bottomLeftButtonActionPerformed

        if (gameType == "twoPlayer") {

            if (turnChoice == "X") {

                bottomLeftButton.setText("X");

                turnChoice = "O";

            } else if (turnChoice == "O") {

                bottomLeftButton.setText("O");

                turnChoice = "X";

            }

            numButtonsClicked++;

            bottomLeftButton.setEnabled(false);

            checkWin();

            checkDraw();

        } else if (gameType == "PlayerVsAI") {

            bottomLeftButton.setText("X");

            bottomLeftButton.setEnabled(false);

            playerViewGame[2][0] = "X";

            numButtonsClicked++;

            checkWin();

            checkDraw();

            if (playerWon == false) {

                AIChoose();

            }

        }

    }//GEN-LAST:event_bottomLeftButtonActionPerformed

    /**
     * This method is called when the two player button is clicked, this button
     * will do the same as the player vs AI button where it resets all the
     * variables to prepare for a new game but the gameType variable will be
     * different as it will prepare the application for a two player game
     * instead of a player vs AI game.
     *
     * @param evt
     */
    private void twoPlayerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_twoPlayerButtonActionPerformed

        twoPlayerButton.setText("Two Player");

        highscoreText.setVisible(false);

        nameText.setVisible(false);

        submitName.setVisible(false);

        resetPlayerArray();

        gameType = "twoPlayer";

        enableButtons();

        resetTextButtons();

        numButtonsClicked = 0;

        playerWon = false;

        messageText.setText("");

        playerAIButton.setEnabled(false);

        twoPlayerButton.setEnabled(false);

        playAgainButton.setEnabled(false);

        xNumWins = 0;

        oNumWins = 0;

        xWins.setText("X Wins = 0");

        oWins.setText("O Wins = 0");
    }//GEN-LAST:event_twoPlayerButtonActionPerformed

    /**
     * When the player vs AI button is clicked it calls this method which reads
     * the high score using a reader by calling the readHighscore method. It
     * then sets all the booleans, integers, and strings, etc to default so that
     * the application is ready for a new game.
     *
     * @param evt
     */
    private void playerAIButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_playerAIButtonActionPerformed

        readHighscore();

        highscoreText.setVisible(false);

        nameText.setVisible(false);

        submitName.setVisible(false);

        resetPlayerArray();

        gameType = "PlayerVsAI";

        enableButtons();

        resetTextButtons();

        numButtonsClicked = 0;

        playerWon = false;

        messageText.setText("");

        playerAIButton.setEnabled(false);

        twoPlayerButton.setEnabled(false);

        playAgainButton.setEnabled(false);

        twoPlayerButton.setText("Two Player");

        xNumWins = 0;

        oNumWins = 0;

        xWins.setText("X Wins = 0");

        oWins.setText("O Wins = 0");

    }//GEN-LAST:event_playerAIButtonActionPerformed

    private void thirdPlaceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_thirdPlaceActionPerformed

    }//GEN-LAST:event_thirdPlaceActionPerformed

    private void fourthPlaceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fourthPlaceActionPerformed

    }//GEN-LAST:event_fourthPlaceActionPerformed

    private void fifthPlaceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fifthPlaceActionPerformed

    }//GEN-LAST:event_fifthPlaceActionPerformed

    private void sixthPlaceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sixthPlaceActionPerformed

    }//GEN-LAST:event_sixthPlaceActionPerformed

    /**
     * This method is called when the submit button is clicked whenever a player
     * has reached a new high score. This method first off calls the
     * setHighscore method that checks if the player has reached a new highs
     * core, it then creates a writer which then takes all the scores and names
     * on the leader board and writes it into the highscoreInfo text file which
     * is then later on read when needed to be updates
     *
     * @param evt
     */
    private void submitNameActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_submitNameActionPerformed
        try {
            
            if(!nameText.getText().contains(" ") && !nameText.getText().contains(",") && !nameText.getText().equals("")) {

            setHighscore();

            BufferedWriter writer = new BufferedWriter(new FileWriter("src/tictactoe/highscoreInfo.txt"));

            writer.write(firstPlace.getText() + "," + firstPlaceCount.getText() + " " + secondPlace.getText() + "," + secondPlaceCount.getText() + " " + thirdPlace.getText() + "," + thirdPlaceCount.getText() + " " + fourthPlace.getText() + "," + fourthPlaceCount.getText() + " " + fifthPlace.getText() + "," + fifthPlaceCount.getText() + " " + sixthPlace.getText() + "," + sixthPlaceCount.getText());

            writer.close();

            submitName.setEnabled(false);
            
            } else {
                System.out.println("ERROR INVALID NAME");
            }

        } catch (IOException ex) {

        }
    }//GEN-LAST:event_submitNameActionPerformed

    private void nameTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nameTextActionPerformed

    }//GEN-LAST:event_nameTextActionPerformed

    /**
     * Whenever the play again button is clicked, it resets all the booleans,
     * Strings, integers, etc. Calls the reset player array method and the reset
     * text buttons method which simply make the application ready to play again
     * if the user is intending on playing again.
     *
     * @param evt
     */
    private void playAgainButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_playAgainButtonActionPerformed

        enableButtons();

        highscoreText.setVisible(false);

        nameText.setVisible(false);

        submitName.setVisible(false);

        resetPlayerArray();

        resetTextButtons();

        numButtonsClicked = 0;

        playerWon = false;

        messageText.setText("");

        playAgainButton.setEnabled(false);
    }//GEN-LAST:event_playAgainButtonActionPerformed

    /**
     * This method checks if there has been a draw, if there is no winner and
     * the numButtonsClicked has reached 9 meaning that all of the buttons have
     * been pressed and no other option is available, then the game resets and
     * tells the user that it is a draw by setting the text of a label.
     */
    public void checkDraw() {

        if (numButtonsClicked == 9 && playerWon == false) {

            messageText.setText("Draw!!");

            disableButtons();

            numButtonsClicked = 0;

            messageText.setText("Draw!!");

            turnChoice = "X";

            playAgainButton.setEnabled(true);

        }

    }

    /**
     * This checkWin method checks if either player O or player X has won by
     * checking every possible winning condition and seeing if it is true, if it
     * is the game is reset and a label text is set to say who won the game. It
     * also adds either the X number of wins or O number of wins so that a
     * leader board can be used to keep track of which players should be on the
     * leader board. This uses a simple integer and calls the checkHighscore
     * method that sees that if the number of wins is greater than a certain
     * place on the leader board.
     */
    public void checkWin() {

        //Checks every single possible win condition for O to win and vise versa with the else statement below
        if ((topLeftButton.getText().equals("O") && topMidButton.getText().equals("O") && topRightButton.getText().equals("O"))
                || (midLeftButton.getText().equals("O") && midMidButton.getText().equals("O") && midRightButton.getText().equals("O"))
                || (bottomLeftButton.getText().equals("O") && bottomMidButton.getText().equals("O") && bottomRightButton.getText().equals("O"))
                || (topLeftButton.getText().equals("O") && midMidButton.getText().equals("O") && bottomRightButton.getText().equals("O"))
                || (bottomLeftButton.getText().equals("O") && midMidButton.getText().equals("O") && topRightButton.getText().equals("O"))
                || (topLeftButton.getText().equals("O") && midMidButton.getText().equals("O") && bottomRightButton.getText().equals("O"))
                || (topMidButton.getText().equals("O") && midMidButton.getText().equals("O") && bottomMidButton.getText().equals("O"))
                || (topRightButton.getText().equals("O") && midRightButton.getText().equals("O") && bottomRightButton.getText().equals("O"))
                || (topLeftButton.getText().equals("O") && midLeftButton.getText().equals("O") && bottomLeftButton.getText().equals("O"))) {

            disableButtons();

            messageText.setText("O player wins!!");

            playerWon = true;

            //Keeps track of the number of O wins
            oNumWins++;

            //Prints number of O wins on a label to be easy for the player to see
            oWins.setText("O Wins = " + oNumWins);

            /**
             * If the game type is PlayerVsAI and it's the AI's turn it means
             * that the AI has won as the win condition is true, this will call
             * the checkHighscore method that gives the player a place in the
             * leader-board if they got a good enough score as they have lost to
             * the AI
             */
            if (AITurn == true && gameType == "PlayerVsAI") {

                checkHighscore();

                twoPlayerButton.setEnabled(true);

                twoPlayerButton.setText("Two Player");

                playerAIButton.setEnabled(true);

            }

            //This enabled the buttons to play again or play a different mode
            if (gameType == "twoPlayer") {

                playAgainButton.setEnabled(true);

                playerAIButton.setEnabled(true);

                twoPlayerButton.setEnabled(true);

                twoPlayerButton.setText("2Player/Reset Scores");

            }

        } else if ((topLeftButton.getText().equals("X") && topMidButton.getText().equals("X") && topRightButton.getText().equals("X"))
                || (midLeftButton.getText().equals("X") && midMidButton.getText().equals("X") && midRightButton.getText().equals("X"))
                || (bottomLeftButton.getText().equals("X") && bottomMidButton.getText().equals("X") && bottomRightButton.getText().equals("X"))
                || (topLeftButton.getText().equals("X") && midMidButton.getText().equals("X") && bottomRightButton.getText().equals("X"))
                || (bottomLeftButton.getText().equals("X") && midMidButton.getText().equals("X") && topRightButton.getText().equals("X"))
                || (topLeftButton.getText().equals("X") && topMidButton.getText().equals("X") && topRightButton.getText().equals("X"))
                || (topLeftButton.getText().equals("X") && midLeftButton.getText().equals("X") && bottomLeftButton.getText().equals("X"))
                || (topMidButton.getText().equals("X") && midMidButton.getText().equals("X") && bottomMidButton.getText().equals("X"))
                || (topRightButton.getText().equals("X") && midRightButton.getText().equals("X") && bottomRightButton.getText().equals("X"))) {

            disableButtons();

            messageText.setText("X player wins!!");

            playerWon = true;

            xNumWins++;

            xWins.setText("X Wins = " + xNumWins);

            if (AITurn == false && gameType == "PlayerVsAI") {

                playAgainButton.setEnabled(true);

                twoPlayerButton.setEnabled(true);

                twoPlayerButton.setText("2Player");

            }

            if (gameType == "twoPlayer") {

                playAgainButton.setEnabled(true);

                playerAIButton.setEnabled(true);

                twoPlayerButton.setEnabled(true);

                twoPlayerButton.setText("2Player/Reset Scores");

            }

        }

    }

    /**
     * This method is an algorithm that lets the AI play against the player, it
     * first checks if there is a potential win by checking all possible winning
     * spots using [][] values and decides to either attack by placing between
     * two O's or defend by placing between two X's, AI also has if statements
     * to block player from winning if they have two X's in a row etc. This code
     * uses a series of loops and if statements that check a whole row every
     * time so check if there is a potential win in a certain spot which the AI
     * can then identify and place and O down.
     */
    public void AIChoose() { //first [] is y axis and second [] is x axis

        try {

            foundASpot = false;

            needToPick = true;

            AITurn = true;

            /**
             * These series of if statements use a 2d array using the y and x
             * axis to figure out the best possible move for the AI, in this
             * first if statement it checks if the player's view of the game
             * which is saved in a 2d array has an X or an O on any of the
             * squares in the first column and then goes through a series of if
             * statements to figure out which exact space has what on it. This
             * is done using a for loop and the y or x axis being checked every
             * time the for loop is true which in this case is only is only 2 as
             * both x and y axis have 0, 1, 2, array slots, and the variable of
             * i in the for loop is used to check every single axis/square in in
             * the players view of the game. This is repeated throughout all of
             * the for loops and if statements in the AIChoose method, only thing
             * different is the variables and which squares the AI is checking.
             */
            if (((!playerViewGame[0][0].equals("N")) || (!playerViewGame[1][0].equals("N")) || (!playerViewGame[2][0].equals("N"))) && AITurn == true) {

                foundUsedSpace = 0;

                emptySpace = 0;

                for (int i = 0; i < 3; i++) {

                    if (!playerViewGame[i][0].equals("N")) {

                        foundUsedSpace++;

                    } else {

                        emptySpace = i;

                    }

                    if (foundUsedSpace == 2) {

                        if (i == 2) {

// this if statement simply checks two certain buttons so that they equal X by making sure that i = 2 and by using i - 1 and i - 2 it checks the possible spots without using lots of other if statements 
                            if (((playerViewGame[i][0].equals("X") && playerViewGame[i - 1][0].equals("X") && playerViewGame[i - 2][0].equals("N")) || (playerViewGame[i][0].equals("O") && playerViewGame[i - 1][0].equals("O") && playerViewGame[i - 2][0].equals("N")))) {

                                positionValue = 0;

                                leftVerticalRow();

                            }

                            if (((playerViewGame[i][0].equals("X") && playerViewGame[i - 2][0].equals("X") && playerViewGame[i - 1][0].equals("N")) || (playerViewGame[i][0].equals("O") && playerViewGame[i - 2][0].equals("O") && playerViewGame[i - 1][0].equals("N")))) {

                                positionValue = 1;

                                leftVerticalRow();

                            }

                        } else if (i == 1) {

                            if (((playerViewGame[i][0].equals("X") && playerViewGame[i - 1][0].equals("X") && playerViewGame[i + 1][0].equals("N")) || (playerViewGame[i][0].equals("O") && playerViewGame[i - 1][0].equals("O") && playerViewGame[i + 1][0].equals("N")))) {

                                positionValue = 2;

                                leftVerticalRow();

                            }

                        }
                    }
                }
            }

            if (((!playerViewGame[0][1].equals("N")) || (!playerViewGame[1][1].equals("N")) || (!playerViewGame[2][1].equals("N"))) && AITurn == true) {

                foundUsedSpace = 0;

                emptySpace = 0;

                for (int i = 0; i < 3; i++) {

                    if (!playerViewGame[i][1].equals("N")) {

                        foundUsedSpace++;

                    } else {

                        emptySpace = i;

                    }

                    if (foundUsedSpace == 2) {

                        if (i == 2) {

// this if statement simply checks two certain buttons so that they equal X by making sure that i = 2 and by using i - 1 and i - 2 it checks the possible spots without using lots of other if statements
                            if (((playerViewGame[i][1].equals("X") && playerViewGame[i - 1][1].equals("X") && playerViewGame[i - 2][1].equals("N")) || (playerViewGame[i][1].equals("O") && playerViewGame[i - 1][1].equals("O") && playerViewGame[i - 2][1].equals("N")))) {

                                positionValue = 0;

                                midVerticalRow();

                            }

                            if (((playerViewGame[i][1].equals("X") && playerViewGame[i - 2][1].equals("X") && playerViewGame[i - 1][1].equals("N")) || (playerViewGame[i][1].equals("O") && playerViewGame[i - 2][1].equals("O") && playerViewGame[i - 1][1].equals("N")))) {

                                positionValue = 1;

                                midVerticalRow();

                            }

                        } else if (i == 1) {

                            if (((playerViewGame[i][1].equals("X") && playerViewGame[i - 1][1].equals("X") && playerViewGame[i + 1][1].equals("N")) || (playerViewGame[i][1].equals("O") && playerViewGame[i - 1][1].equals("O") && playerViewGame[i + 1][1].equals("N")))) {

                                positionValue = 2;

                                midVerticalRow();

                            }

                        }

                    }
                }
            }
            
           if ((!playerViewGame[0][0].equals("N") && !playerViewGame[2][2].equals("N") && !playerViewGame[1][1].equals("X")) || (!playerViewGame[2][0].equals("N") && !playerViewGame[0][2].equals("N") && !playerViewGame[1][1].equals("X")) && AITurn == true) {
 if (playerViewGame[1][0].equals("N") && playerViewGame[0][1].equals("N") && playerViewGame[2][1].equals("N") && playerViewGame[1][2].equals("N")) {
     
          foundEmptySpace = false;

            while (foundEmptySpace == false) {

                x = Math.random();

                y = Math.random();

                xAxis = 0;
                yAxis = 0;

                if (x <= 0.25) {

                    xAxis = 1;
                    yAxis = 0;

                } else if (0.25 < x && x <= 0.5) {

                    xAxis = 0;
                    yAxis = 1;

                } else if (0.5 < x && x <= 0.75) {
                    
                    xAxis = 2;
                    yAxis = 1;
                    
                } else if (x > 0.75) {
                    
                    xAxis = 1;
                    yAxis = 2;
                    
                }

                if (playerViewGame[yAxis][xAxis].equals("N")) {

                    foundEmptySpace = true;

                    if (yAxis == 1 && xAxis == 0) {

                        midLeftButton.setText("O");

                        midLeftButton.setEnabled(false);

                    } else if (yAxis == 0 && xAxis == 1) {

                        topMidButton.setText("O");

                        topMidButton.setEnabled(false);

                    } else if (yAxis == 1 && xAxis == 2) {

                        midRightButton.setText("O");

                        midRightButton.setEnabled(false);

                    } else if (yAxis == 2 && xAxis == 1) {

                        bottomMidButton.setText("O");

                        bottomMidButton.setEnabled(false);

                    }

                    playerViewGame[yAxis][xAxis] = "O";

                    numButtonsClicked++;
                    
                    needToPick = false;

            foundASpot = true;
            
            AITurn = false;

                    checkWin();

                    checkDraw();
            }
            }
 
            }
            }

            if (((!playerViewGame[0][2].equals("N")) || (!playerViewGame[1][2].equals("N")) || (!playerViewGame[2][2].equals("N"))) && AITurn == true) {

                foundUsedSpace = 0;

                emptySpace = 0;

                for (int i = 0; i < 3; i++) {

                    if (!playerViewGame[i][2].equals("N")) {

                        foundUsedSpace++;

                    } else {

                        emptySpace = i;

                    }

                    if (foundUsedSpace == 2) {

                        if (i == 2) {

// this if statement simply checks two certain buttons so that they equal X by making sure that i = 2 and by using i - 1 and i - 2 it checks the possible spots without using lots of other if statements
                            if (((playerViewGame[i][2].equals("X") && playerViewGame[i - 1][2].equals("X") && playerViewGame[i - 2][2].equals("N")) || (playerViewGame[i][2].equals("O") && playerViewGame[i - 1][2].equals("O") && playerViewGame[i - 2][2].equals("N")))) { //need to fix this line

                                positionValue = 0;

                                rightVerticalRow();

                            }

                            if (((playerViewGame[i][2].equals("X") && playerViewGame[i - 2][2].equals("X") && playerViewGame[i - 1][2].equals("N")) || (playerViewGame[i][2].equals("O") && playerViewGame[i - 2][2].equals("O") && playerViewGame[i - 1][2].equals("N")))) {

                                positionValue = 1;

                                rightVerticalRow();

                            }

                        } else if (i == 1) {

                            if (((playerViewGame[i][2].equals("X") && playerViewGame[i - 1][2].equals("X") && playerViewGame[i + 1][2].equals("N")) || (playerViewGame[i][2].equals("O") && playerViewGame[i - 1][2].equals("O") && playerViewGame[i + 1][2].equals("N")))) {

                                positionValue = 2;

                                rightVerticalRow();

                            }

                        }
                    }
                }
            }

            if (((!playerViewGame[0][0].equals("N")) || (!playerViewGame[0][1].equals("N")) || (!playerViewGame[0][2].equals("N"))) && AITurn == true) {

                foundUsedSpace = 0;

                emptySpace = 0;

                for (int i = 0; i < 3; i++) {

                    if (!playerViewGame[0][i].equals("N")) {

                        foundUsedSpace++;

                    } else {

                        emptySpace = i;

                    }

                    if (foundUsedSpace == 2) {

                        if (i == 2) {

// this if statement simply checks two certain buttons so that they equal X by making sure that i = 2 and by using i - 1 and i - 2 it checks the possible spots without using lots of other if statements
                            if (((playerViewGame[0][i].equals("X") && playerViewGame[0][i - 1].equals("X") && playerViewGame[0][i - 2].equals("N")) || (playerViewGame[0][i].equals("O") && playerViewGame[0][i - 1].equals("O") && playerViewGame[0][i - 2].equals("N")))) {

                                positionValue = 0;

                                topRow();

                            }

                            if (((playerViewGame[0][i].equals("X") && playerViewGame[0][i - 2].equals("X") && playerViewGame[0][i - 1].equals("N")) || (playerViewGame[0][i].equals("O") && playerViewGame[0][i - 2].equals("O") && playerViewGame[0][i - 1].equals("N")))) {

                                positionValue = 1;

                                topRow();

                            }

                        } else if (i == 1) {

                            if (((playerViewGame[0][i].equals("X") && playerViewGame[0][i - 1].equals("X") && playerViewGame[0][i + 1].equals("N")) || (playerViewGame[0][i].equals("O") && playerViewGame[0][i - 1].equals("O") && playerViewGame[0][i + 1].equals("N")))) {

                                positionValue = 2;

                                topRow();

                            }

                        }

                    }
                }
            }

            if (((!playerViewGame[1][0].equals("N")) || (!playerViewGame[1][1].equals("N")) || (!playerViewGame[1][2].equals("N"))) && AITurn == true) {

                foundUsedSpace = 0;

                emptySpace = 0;

                foundSpareSpace = false;

                for (int i = 0; i < 3; i++) {

                    if (!playerViewGame[1][i].equals("N")) {

                        foundUsedSpace++;

                    } else {

                        emptySpace = i;

                    }

                    if (foundUsedSpace == 2) {

                        if (i == 2) {

// this if statement simply checks two certain buttons so that they equal X by making sure that i = 2 and by using i - 1 and i - 2 it checks the possible spots without using lots of other if statements
                            if (((playerViewGame[1][i].equals("X") && playerViewGame[1][i - 1].equals("X") && playerViewGame[1][i - 2].equals("N")) || (playerViewGame[1][i].equals("O") && playerViewGame[1][i - 1].equals("O") && playerViewGame[1][i - 2].equals("N")))) {

                                positionValue = 0;

                                midRow();

                            }

                            if (((playerViewGame[1][i].equals("X") && playerViewGame[1][i - 2].equals("X") && playerViewGame[1][i - 1].equals("N")) || (playerViewGame[1][i].equals("O") && playerViewGame[1][i - 2].equals("O") && playerViewGame[1][i - 1].equals("N")))) {

                                midRow();

                                positionValue = 1;

                            }

                        } else if (i == 1) {

                            if (((playerViewGame[1][i].equals("X") && playerViewGame[1][i - 1].equals("X") && playerViewGame[1][i + 1].equals("N")) || (playerViewGame[1][i].equals("O") && playerViewGame[1][i - 1].equals("O") && playerViewGame[1][i + 1].equals("N")))) {

                                positionValue = 2;

                                midRow();

                            }

                        }

                    }
                }
            }
            if (((!playerViewGame[2][0].equals("N")) || (!playerViewGame[2][1].equals("N")) || (!playerViewGame[2][2].equals("N"))) && AITurn == true) {

                foundUsedSpace = 0;

                emptySpace = 0;

                for (int i = 0; i < 3; i++) {

                    if (!playerViewGame[2][i].equals("N")) {

                        foundUsedSpace++;

                    } else {

                        emptySpace = i;

                    }

                    if (foundUsedSpace == 2) {

                        if (i == 2) {

// this if statement simply checks two certain buttons so that they equal X by making sure that i = 2 and by using i - 1 and i - 2 it checks the possible spots without using lots of other if statements
                            if (((playerViewGame[2][i].equals("X") && playerViewGame[2][i - 1].equals("X") && playerViewGame[2][i - 2].equals("N")) || (playerViewGame[2][i].equals("O") && playerViewGame[2][i - 1].equals("O") && playerViewGame[2][i - 2].equals("N")))) {

                                positionValue = 0;

                                bottomRow();

                            }

                            if (((playerViewGame[2][i].equals("X") && playerViewGame[2][i - 2].equals("X") && playerViewGame[2][i - 1].equals("N")) || (playerViewGame[2][i].equals("O") && playerViewGame[2][i - 2].equals("O") && playerViewGame[2][i - 1].equals("N")))) {

                                positionValue = 1;

                                bottomRow();

                            }

                        } else if (i == 1) {

                            if (((playerViewGame[2][i].equals("X") && playerViewGame[2][i - 1].equals("X") && playerViewGame[2][i + 1].equals("N")) || (playerViewGame[2][i].equals("O") && playerViewGame[2][i - 1].equals("O") && playerViewGame[2][i + 1].equals("N")))) {

                                positionValue = 2;

                                bottomRow();

                            }

                        }

                    }
                }
            }

            if (((!playerViewGame[0][0].equals("N")) || (!playerViewGame[1][1].equals("N")) || (!playerViewGame[2][2].equals("N"))) && AITurn == true) {

                foundUsedSpace = 0;

                emptySpace = 0;

                for (int i = 0; i < 3; i++) {

                    if (!playerViewGame[i][i].equals("N")) {

                        foundUsedSpace++;

                    } else {

                        emptySpace = i;

                    }

                    if (foundUsedSpace == 2) {

                        if (i == 2) {

// this if statement simply checks two certain buttons so that they equal X by making sure that i = 2 and by using i - 1 and i - 2 it checks the possible spots without using lots of other if statements
                            if (((playerViewGame[i][i].equals("X") && playerViewGame[i - 1][i - 1].equals("X") && playerViewGame[i - 2][i - 2].equals("N")) || (playerViewGame[i][i].equals("O") && playerViewGame[i - 1][i - 1].equals("O") && playerViewGame[i - 2][i - 2].equals("N")))) {

                                positionValue = 0;

                                diagonalRow();

                            }

                            if (((playerViewGame[i][i].equals("X") && playerViewGame[i - 2][i - 2].equals("X") && playerViewGame[i - 1][i - 1].equals("N")) || (playerViewGame[i][i].equals("O") && playerViewGame[i - 2][i - 2].equals("O") && playerViewGame[i - 1][i - 1].equals("N")))) {

                                positionValue = 1;

                                diagonalRow();

                            }

                        } else if (i == 1) {

                            if (((playerViewGame[i][i].equals("X") && playerViewGame[i - 1][i - 1].equals("X") && playerViewGame[i + 1][i + 1].equals("N")) || (playerViewGame[i][i].equals("O") && playerViewGame[i - 1][i - 1].equals("O") && playerViewGame[i + 1][i + 1].equals("N")))) {

                                positionValue = 2;

                                diagonalRow();

                            }

                        }

                    }
                }
            }

            if (((!playerViewGame[0][2].equals("N")) || (!playerViewGame[1][1].equals("N")) || (!playerViewGame[2][0].equals("N"))) && AITurn == true) {

                foundUsedSpace = 0;

                emptySpace = 0;

                for (int i = 0; i < 3; i++) {

                    if (i == 0) {

                        if (!playerViewGame[i + 2][i].equals("N")) {

                            foundUsedSpace++;

                        } else {

                            emptySpace = i;

                        }

                    } else if (i == 1) {

                        if (!playerViewGame[i][i].equals("N")) {

                            foundUsedSpace++;

                        } else {

                            emptySpace = i;

                        }

                    } else if (i == 2) {

                        if (!playerViewGame[i - 2][i].equals("N")) {

                            foundUsedSpace++;

                        } else {

                            emptySpace = i;

                        }
                    }

                    if (foundUsedSpace == 2) {

                        if (i == 2) {

// this if statement simply checks two certain buttons so that they equal X by making sure that i = 2 and by using i - 1 and i - 2 it checks the possible spots without using lots of other if statements
                            if (((playerViewGame[i - 2][i].equals("X") && playerViewGame[i - 1][i - 1].equals("X") && playerViewGame[i][i - 2].equals("N")) || (playerViewGame[i - 2][i].equals("O") && playerViewGame[i - 1][i - 1].equals("O") && playerViewGame[i][i - 2].equals("N")))) {

                                positionValue = 2;

                                secondDiagonalRow();

                            }

                            if (((playerViewGame[i][i - 2].equals("X") && playerViewGame[i - 2][i].equals("X") && playerViewGame[i - 1][i - 1].equals("N")) || (playerViewGame[i][i - 2].equals("O") && playerViewGame[i - 2][i].equals("O") && playerViewGame[i - 1][i - 1].equals("N")))) {

                                positionValue = 1;

                                secondDiagonalRow();

                            }

                        } else if (i == 1) {

                            if (((playerViewGame[i][i].equals("X") && playerViewGame[i + 1][i - 1].equals("X") && playerViewGame[i - 1][i + 1].equals("N")) || (playerViewGame[i][i].equals("O") && playerViewGame[i + 1][i - 1].equals("O") && playerViewGame[i - 1][i + 1].equals("N")))) {

                                positionValue = 0;

                                secondDiagonalRow();

                            }

                        }

                    }
                }
            }

            if (needToPick == true && AITurn == true) {

                AIChooseRandom();

            }

        } catch (NullPointerException ex) {

        }

    }

    /**
     * This method is called when the player is not attacking by placing two X's
     * in a certain position so the AI goes through it's entire AIChoose method
     * without finding an optimal move so it chooses the next best move which is
     * just a randomizer in any four corners, this is done by using Math.random
     * which gives a value between 0 and 1, this allows the AI to randomly
     * choose a corner. The first if else statements simply check which corner
     * squares are available and takes that into consideration when using the
     * randomizer, this just assures that the odds for every single corner is
     * equal.
     */
    public void AIChooseRandom() {

        if (playerViewGame[1][1].equals("N")) {

            playerViewGame[1][1] = "O";

            midMidButton.setText("O");

            midMidButton.setEnabled(false);

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (playerViewGame[0][0].equals("N")
                || playerViewGame[2][0].equals("N")
                || playerViewGame[0][2].equals("N")
                || playerViewGame[2][2].equals("N")) {

            foundEmptySpace = false;

            while (foundEmptySpace == false) {

                x = Math.random();

                y = Math.random();

                yAxis = 0;

                xAxis = 0;

                if (x >= 0.5) {

                    xAxis = 2;

                } else {

                    xAxis = 0;

                }

                if (y >= 0.5) {

                    yAxis = 2;

                } else {

                    yAxis = 0;

                }
                if (playerViewGame[yAxis][xAxis].equals("N")) {

                    foundEmptySpace = true;

                    if (yAxis == 0 && xAxis == 0) {

                        topLeftButton.setText("O");

                        topLeftButton.setEnabled(false);

                    } else if (yAxis == 2 && xAxis == 0) {

                        bottomLeftButton.setText("O");

                        bottomLeftButton.setEnabled(false);

                    } else if (yAxis == 0 && xAxis == 2) {

                        topRightButton.setText("O");

                        topRightButton.setEnabled(false);

                    } else if (yAxis == 2 && xAxis == 2) {

                        bottomRightButton.setText("O");

                        bottomRightButton.setEnabled(false);

                    }

                    playerViewGame[yAxis][xAxis] = "O";

                    numButtonsClicked++;

                    checkWin();

                    checkDraw();

                }
            }
        } else if (playerViewGame[0][1].equals("N")
                || playerViewGame[1][0].equals("N")
                || playerViewGame[1][2].equals("N")
                || playerViewGame[2][1].equals("N")) {

            foundEmptySpace = false;

            while (foundEmptySpace == false) {

                x = Math.random();

                y = Math.random();

                yAxis = 0;

                xAxis = 0;

                if (x >= 0.7) {

                    xAxis = 1;

                } else if (x >= 0.5) {

                    xAxis = 2;

                } else {

                    xAxis = 0;

                }

                if (y >= 0.7) {

                    yAxis = 1;

                } else if (y >= 0.5) {

                    yAxis = 2;

                } else {

                    yAxis = 0;

                }

                if (playerViewGame[yAxis][xAxis].equals("N")) {

                    foundEmptySpace = true;

                    if (yAxis == 0 && xAxis == 1) {

                        topMidButton.setText("O");

                        topMidButton.setEnabled(false);

                    } else if (yAxis == 1 && xAxis == 0) {

                        midLeftButton.setText("O");

                        midLeftButton.setEnabled(false);

                    } else if (yAxis == 1 && xAxis == 2) {

                        midRightButton.setText("O");

                        midRightButton.setEnabled(false);

                    } else if (yAxis == 2 && xAxis == 1) {

                        bottomMidButton.setText("O");

                        bottomMidButton.setEnabled(false);

                    }

                    playerViewGame[yAxis][xAxis] = "O";

                    numButtonsClicked++;

                    checkWin();

                    checkDraw();

                }
            }
        }

    }

    /**
     * This method just clears the playerViewGame 2d array for a new game so
     * that the AI does not get mixed up with the previous game played
     */
    public void resetPlayerArray() {

        playerViewGame[0][0] = "N";
        playerViewGame[0][1] = "N";
        playerViewGame[0][2] = "N";
        playerViewGame[1][0] = "N";
        playerViewGame[1][1] = "N";
        playerViewGame[1][2] = "N";
        playerViewGame[2][0] = "N";
        playerViewGame[2][1] = "N";
        playerViewGame[2][2] = "N";

    }

    /**
     * This method is used after the AIChoose method has decided the most
     * optimal axis to play on, for example the last column in this method and
     * checks to see which positionValue the AI choose as the most optimal move
     * to take. This then changes certain values to tell the code that is run
     * afterwards that the AI has made a choice and it has found a spot, these
     * values are the needToPick and the foundASpot variables which are used
     * throughout to assure that the AI makes a move if there is an option to
     * make one. After making the move it calls two methods that check for
     * either a win or draw.
     */
    public void rightVerticalRow() {

        if (positionValue == 0) {

            needToPick = false;

            foundASpot = true;

            topRightButton.setText("O");

            topRightButton.setEnabled(false);

            playerViewGame[positionValue][2] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 1) {

            needToPick = false;

            foundASpot = true;

            midRightButton.setText("O");

            midRightButton.setEnabled(false);

            playerViewGame[positionValue][2] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 2) {

            needToPick = false;

            foundASpot = true;

            bottomRightButton.setText("O");

            bottomRightButton.setEnabled(false);

            playerViewGame[positionValue][2] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        }

        AITurn = false;
    }

    /**
     * This method is used after the AIChoose method has decided the most
     * optimal axis to play on, for example the top row in this method and
     * checks to see which positionValue the AI choose as the most optimal move
     * to take. This then changes certain values to tell the code that is run
     * afterwards that the AI has made a choice and it has found a spot, these
     * values are the needToPick and the foundASpot variables which are used
     * throughout to assure that the AI makes a move if there is an option to
     * make one. After making the move it calls two methods that check for
     * either a win or draw.
     */
    public void topRow() {

        if (positionValue == 0) {

            needToPick = false;

            foundASpot = true;

            topLeftButton.setText("O");

            topLeftButton.setEnabled(false);

            playerViewGame[0][positionValue] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 1) {

            needToPick = false;

            foundASpot = true;

            topMidButton.setText("O");

            topMidButton.setEnabled(false);

            playerViewGame[0][positionValue] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 2) {

            needToPick = false;

            foundASpot = true;

            topRightButton.setText("O");

            topRightButton.setEnabled(false);

            playerViewGame[0][positionValue] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        }

        AITurn = false;
    }

    /**
     * This method is used after the AIChoose method has decided the most
     * optimal axis to play on, for example the middle row in this method and
     * checks to see which positionValue the AI choose as the most optimal move
     * to take. This then changes certain values to tell the code that is run
     * afterwards that the AI has made a choice and it has found a spot, these
     * values are the needToPick and the foundASpot variables which are used
     * throughout to assure that the AI makes a move if there is an option to
     * make one. After making the move it calls two methods that check for
     * either a win or draw.
     */
    public void midRow() {

        if (positionValue == 0) {

            needToPick = false;

            foundASpot = true;

            midLeftButton.setText("O");

            midLeftButton.setEnabled(false);

            playerViewGame[1][positionValue] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 1) {

            needToPick = false;

            foundASpot = true;

            midMidButton.setText("O");

            midMidButton.setEnabled(false);

            playerViewGame[1][positionValue] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 2) {

            needToPick = false;

            foundASpot = true;

            midRightButton.setText("O");

            midRightButton.setEnabled(false);

            playerViewGame[1][positionValue] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        }

        AITurn = false;
    }

    /**
     * This method is used after the AIChoose method has decided the most
     * optimal axis to play on, for example the bottom row in this method and
     * checks to see which positionValue the AI choose as the most optimal move
     * to take. This then changes certain values to tell the code that is run
     * afterwards that the AI has made a choice and it has found a spot, these
     * values are the needToPick and the foundASpot variables which are used
     * throughout to assure that the AI makes a move if there is an option to
     * make one. After making the move it calls two methods that check for
     * either a win or draw.
     */
    public void bottomRow() {

        if (positionValue == 0) {

            needToPick = false;

            foundASpot = true;

            bottomLeftButton.setText("O");

            bottomLeftButton.setEnabled(false);

            playerViewGame[2][positionValue] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 1) {

            needToPick = false;

            foundASpot = true;

            bottomMidButton.setText("O");

            bottomMidButton.setEnabled(false);

            playerViewGame[2][positionValue] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 2) {

            needToPick = false;

            foundASpot = true;

            bottomRightButton.setText("O");

            bottomRightButton.setEnabled(false);

            playerViewGame[2][positionValue] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        }

        AITurn = false;
    }

    /**
     * This method is used after the AIChoose method has decided the most
     * optimal axis to play on, for example the middle column in this method and
     * checks to see which positionValue the AI choose as the most optimal move
     * to take. This then changes certain values to tell the code that is run
     * afterwards that the AI has made a choice and it has found a spot, these
     * values are the needToPick and the foundASpot variables which are used
     * throughout to assure that the AI makes a move if there is an option to
     * make one. After making the move it calls two methods that check for
     * either a win or draw.
     */
    public void midVerticalRow() {

        if (positionValue == 0) {

            needToPick = false;

            foundASpot = true;

            topMidButton.setText("O");

            topMidButton.setEnabled(false);

            playerViewGame[positionValue][1] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 1) {

            needToPick = false;

            foundASpot = true;

            midMidButton.setText("O");

            midMidButton.setEnabled(false);

            playerViewGame[positionValue][1] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 2) {

            needToPick = false;

            foundASpot = true;

            bottomMidButton.setText("O");

            bottomMidButton.setEnabled(false);

            playerViewGame[positionValue][1] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        }

        AITurn = false;
    }

    /**
     * This method is used after the AIChoose method has decided the most
     * optimal axis to play on, for example the first column in this method and
     * checks to see which positionValue the AI choose as the most optimal move
     * to take. This then changes certain values to tell the code that is run
     * afterwards that the AI has made a choice and it has found a spot, these
     * values are the needToPick and the foundASpot variables which are used
     * throughout to assure that the AI makes a move if there is an option to
     * make one. After making the move it calls two methods that check for
     * either a win or draw.
     */
    public void leftVerticalRow() {

        if (positionValue == 0) {

            needToPick = false;

            foundASpot = true;

            topLeftButton.setText("O");

            topLeftButton.setEnabled(false);

            playerViewGame[positionValue][0] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 1) {

            needToPick = false;

            foundASpot = true;

            midLeftButton.setText("O");

            midLeftButton.setEnabled(false);

            playerViewGame[positionValue][0] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 2) {

            needToPick = false;

            foundASpot = true;

            bottomLeftButton.setText("O");

            bottomLeftButton.setEnabled(false);

            playerViewGame[positionValue][0] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        }

        AITurn = false;
    }

    /**
     * This method is used after the AIChoose method has decided the most
     * optimal axis to play on, for example the diagonal axis from top left to
     * bottom right in this method and checks to see which positionValue the AI
     * choose as the most optimal move to take. This then changes certain values
     * to tell the code that is run afterwards that the AI has made a choice and
     * it has found a spot, these values are the needToPick and the foundASpot
     * variables which are used throughout to assure that the AI makes a move if
     * there is an option to make one. After making the move it calls two
     * methods that check for either a win or draw.
     */
    public void diagonalRow() {

        if (positionValue == 0) {

            needToPick = false;

            foundASpot = true;

            topLeftButton.setText("O");

            topLeftButton.setEnabled(false);

            playerViewGame[positionValue][0] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 1) {

            needToPick = false;

            foundASpot = true;

            midMidButton.setText("O");

            midMidButton.setEnabled(false);

            playerViewGame[positionValue][1] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 2) {

            needToPick = false;

            foundASpot = true;

            bottomRightButton.setText("O");

            bottomRightButton.setEnabled(false);

            playerViewGame[positionValue][2] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        }

        AITurn = false;
    }

    /**
     * This method is used after the AIChoose method has decided the most
     * optimal axis to play on, for example the diagonal axis from top right to
     * bottom left in this method and checks to see which positionValue the AI
     * choose as the most optimal move to take. This then changes certain values
     * to tell the code that is run afterwards that the AI has made a choice and
     * it has found a spot, these values are the needToPick and the foundASpot
     * variables which are used throughout to assure that the AI makes a move if
     * there is an option to make one. After making the move it calls two
     * methods that check for either a win or draw.
     */
    public void secondDiagonalRow() {

        if (positionValue == 0) {

            needToPick = false;

            foundASpot = true;

            topRightButton.setText("O");

            topRightButton.setEnabled(false);

            playerViewGame[positionValue][2] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 1) {

            needToPick = false;

            foundASpot = true;

            midMidButton.setText("O");

            midMidButton.setEnabled(false);

            playerViewGame[positionValue][1] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        } else if (positionValue == 2) {

            needToPick = false;

            foundASpot = true;

            bottomLeftButton.setText("O");

            bottomLeftButton.setEnabled(false);

            playerViewGame[positionValue][0] = "O";

            numButtonsClicked++;

            checkWin();

            checkDraw();

        }

        AITurn = false;
    }

    /**
     * This method checks the high-score after a player loses to the AI, this
     * gives the most amount of wins consecutively that the program then checks
     * if the player has won a spot with a score greater than the last place on
     * the leader-board, if so then it enables all the buttons and text boxes
     * that allow the player to insert their name for a high score
     */
    public void checkHighscore() {

        if (Integer.parseInt(sixthPlaceCount.getText()) < xNumWins) {

            highscoreText.setVisible(true);

            nameText.setVisible(true);

            nameText.setEnabled(true);

            nameText.setText("");

            submitName.setVisible(true);

            submitName.setEnabled(true);

        }

    }

    /**
     * This method is called once the submit button is pressed which is only
     * enabled after the checkHighscore method enables it, this method now
     * checks which spot the player has earned by comparing their score to the
     * current high-score places, and when it finds the players placing then it
     * moves all other players down and inserts the new player's name into the
     * leader-board
     */
    public void setHighscore() {

        if (Integer.parseInt(firstPlaceCount.getText()) < xNumWins) {

            sixthPlaceCount.setText(fifthPlaceCount.getText());
            sixthPlace.setText(fifthPlace.getText());

            fifthPlaceCount.setText(fourthPlaceCount.getText());
            fifthPlace.setText(fourthPlace.getText());

            fourthPlaceCount.setText(thirdPlaceCount.getText());
            fourthPlace.setText(thirdPlace.getText());

            thirdPlaceCount.setText(secondPlaceCount.getText());
            thirdPlace.setText(secondPlace.getText());

            secondPlaceCount.setText(firstPlaceCount.getText());
            secondPlace.setText(firstPlace.getText());

            firstPlace.setText(nameText.getText());

            firstPlaceCount.setText(Integer.toString(xNumWins));

        } else if (Integer.parseInt(secondPlaceCount.getText()) < xNumWins) {

            sixthPlaceCount.setText(fifthPlaceCount.getText());
            sixthPlace.setText(fifthPlace.getText());

            fifthPlaceCount.setText(fourthPlaceCount.getText());
            fifthPlace.setText(fourthPlace.getText());

            fourthPlaceCount.setText(thirdPlaceCount.getText());
            fourthPlace.setText(thirdPlace.getText());

            thirdPlaceCount.setText(secondPlaceCount.getText());
            thirdPlace.setText(secondPlace.getText());

            secondPlace.setText(nameText.getText());

            secondPlaceCount.setText(Integer.toString(xNumWins));

        } else if (Integer.parseInt(thirdPlaceCount.getText()) < xNumWins) {

            sixthPlaceCount.setText(fifthPlaceCount.getText());
            sixthPlace.setText(fifthPlace.getText());

            fifthPlaceCount.setText(fourthPlaceCount.getText());
            fifthPlace.setText(fourthPlace.getText());

            fourthPlaceCount.setText(thirdPlaceCount.getText());
            fourthPlace.setText(thirdPlace.getText());

            thirdPlace.setText(nameText.getText());

            thirdPlaceCount.setText(Integer.toString(xNumWins));

        } else if (Integer.parseInt(fourthPlaceCount.getText()) < xNumWins) {

            sixthPlaceCount.setText(fifthPlaceCount.getText());
            sixthPlace.setText(fifthPlace.getText());

            fifthPlaceCount.setText(fourthPlaceCount.getText());
            fifthPlace.setText(fourthPlace.getText());

            fourthPlace.setText(nameText.getText());

            fourthPlaceCount.setText(Integer.toString(xNumWins));

        } else if (Integer.parseInt(fifthPlaceCount.getText()) < xNumWins) {

            sixthPlaceCount.setText(fifthPlaceCount.getText());
            sixthPlace.setText(fifthPlace.getText());

            fifthPlace.setText(nameText.getText());

            fifthPlaceCount.setText(Integer.toString(xNumWins));

        } else if (Integer.parseInt(sixthPlaceCount.getText()) < xNumWins) {

            sixthPlace.setText(nameText.getText());

            sixthPlaceCount.setText(Integer.toString(xNumWins));
       
        }

    }
    

    /**
     * This readHighscore method reads a text file which has the saved rankings
     * of all the players on the leader-board, the players in the text file are
     * split by using a " ", and the name and actual score are separated by a
     * ",". Once it reads the file and saves all the names in an array, it
     * prints out all of the scores and names on the leader-board.
     */
    public void readHighscore() {

        try {

            BufferedReader reader = new BufferedReader(new FileReader("src/tictactoe/highscoreInfo.txt"));
            String line = "null";
            String words[] = reader.readLine().split(" ");
            String placements[] = {};

            for (int i = 0; i < words.length; i++) {

                placements = words[i].split(",");

                if (i == 0) {

                    firstPlace.setText(placements[0]);
                    firstPlaceCount.setText(placements[1]);

                } else if (i == 1) {

                    secondPlace.setText(placements[0]);
                    secondPlaceCount.setText(placements[1]);

                }
                if (i == 2) {

                    thirdPlace.setText(placements[0]);
                    thirdPlaceCount.setText(placements[1]);

                }
                if (i == 3) {

                    fourthPlace.setText(placements[0]);
                    fourthPlaceCount.setText(placements[1]);

                }
                if (i == 4) {

                    fifthPlace.setText(placements[0]);
                    fifthPlaceCount.setText(placements[1]);

                }
                if (i == 5) {

                    sixthPlace.setText(placements[0]);
                    sixthPlaceCount.setText(placements[1]);

                }

                placements[0] = "";
                placements[1] = "";

            }

        } catch (IOException ex) {

        }

    }

    /**
     * This method enabled all the buttons whenever the game is won, lost or
     * drawn.
     */
    public void enableButtons() {
        topRightButton.setEnabled(true);
        topMidButton.setEnabled(true);
        topLeftButton.setEnabled(true);
        midMidButton.setEnabled(true);
        midRightButton.setEnabled(true);
        midLeftButton.setEnabled(true);
        bottomMidButton.setEnabled(true);
        bottomRightButton.setEnabled(true);
        bottomLeftButton.setEnabled(true);
    }

    /**
     * This disabled all the buttons whenever the game is won, lost or drawn.
     */
    public void disableButtons() {
        topRightButton.setEnabled(false);
        topMidButton.setEnabled(false);
        topLeftButton.setEnabled(false);
        midMidButton.setEnabled(false);
        midRightButton.setEnabled(false);
        midLeftButton.setEnabled(false);
        bottomMidButton.setEnabled(false);
        bottomRightButton.setEnabled(false);
        bottomLeftButton.setEnabled(false);
    }

    /**
     * This method resets all the buttons whenever the game is won, lost, or
     * drawn. It simply sets all the text buttons to blank, ready for a new game
     * to commence.
     */
    public void resetTextButtons() {
        topRightButton.setText("");
        topMidButton.setText("");
        topLeftButton.setText("");
        midMidButton.setText("");
        midRightButton.setText("");
        midLeftButton.setText("");
        bottomMidButton.setText("");
        bottomRightButton.setText("");
        bottomLeftButton.setText("");
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(UserInput.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(UserInput.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(UserInput.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(UserInput.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new UserInput().setVisible(true);
            }
        });
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bottomLeftButton;
    private javax.swing.JButton bottomMidButton;
    private javax.swing.JButton bottomRightButton;
    private javax.swing.JTextField fifthPlace;
    private javax.swing.JTextField fifthPlaceCount;
    private javax.swing.JTextField firstPlace;
    private javax.swing.JTextField firstPlaceCount;
    private javax.swing.JTextField fourthPlace;
    private javax.swing.JTextField fourthPlaceCount;
    private javax.swing.JLabel highscoreText;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel messageText;
    private javax.swing.JButton midLeftButton;
    private javax.swing.JButton midMidButton;
    private javax.swing.JButton midRightButton;
    private javax.swing.JTextField nameText;
    private javax.swing.JLabel oWins;
    private javax.swing.JButton playAgainButton;
    private javax.swing.JButton playerAIButton;
    private javax.swing.JTextField secondPlace;
    private javax.swing.JTextField secondPlaceCount;
    private javax.swing.JTextField sixthPlace;
    private javax.swing.JTextField sixthPlaceCount;
    private javax.swing.JButton submitName;
    private javax.swing.JTextField thirdPlace;
    private javax.swing.JTextField thirdPlaceCount;
    private javax.swing.JLabel title;
    private javax.swing.JButton topLeftButton;
    private javax.swing.JButton topMidButton;
    private javax.swing.JButton topRightButton;
    private javax.swing.JButton twoPlayerButton;
    private javax.swing.JLabel xWins;
    // End of variables declaration//GEN-END:variables
}
